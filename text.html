<!--
前置說明。
    
本程式碼採用了phaser遊戲引擎，因此必須做好前置工作，除了下載基本的js檔外，基本上就是要準備Web伺服器了。
假如你想讀取圖片卻不用伺服器，就會出現問題：

Access to XMLHttpRequest at 'file:///........' from origin 'null' has been blocked by CORS policy: 
Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

遇到的錯誤是CORS（跨來源資源共享）策略錯誤。
瀏覽器阻止了從"null"這個來源（也就是本地檔案系統）載入圖像，因為通常只允許從特定的協定（如http、https）載入跨域資源。
為了解決這個問題，你需要將你的遊戲運行在一個Web伺服器上，而不是直接從本機檔案系統中開啟。

有兩種常見的解決方式：

１、使用本機開發伺服器：
    在你的本機開發環境中，使用諸如Node.js的本機開發伺服器來運行你的遊戲。
２、部署到線上Web伺服器：
    將你的遊戲檔案上傳到一個線上的網路伺服器上，然後透過http或https協議存取你的遊戲。

一旦你將你的遊戲部署到Web伺服器上，你可以透過伺服器提供的URL來存取它，而不會遇到CORS問題。

基本上pjaser教學有告訴你如何使用第一個方法的，但我一直無法弄好joomla，所以我放棄了第一個方法，並使用了chatGPT給的第二種方法。
利用github的page功能，部署一個線上Web伺服器。

-->


<!DOCTYPE html>
<html>
<head>
    <title>Phaser Example</title>
    <script src="phaser.min.js"></script>
</head>
<body>
    <script>

        var config = {              //物件屬性
            type: Phaser.AUTO,      //自動選擇為最好的渲染方式
            width: 800,             //寬高設定
            height: 600,
            physics: {              //加入物理模塊
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false
                }
            },
            scene: {                
                preload: preload,   //加載資料
                create: create,     //創建畫面
                update: update      //刷新畫面
            }
        };

        var score = 0;
        var scoreText;
        var game = new Phaser.Game(config);//建立遊戲物件

        function preload (){
            //image-讀取圖片。命名為'???'，並讀取圖片。
            this.load.image('sky', 'assets/sky.png');
            this.load.image('ground', 'assets/platform.png');
            this.load.image('star', 'assets/star.png');
            this.load.image('bomb', 'assets/bomb.png');

            //spritesheet-精靈圖像，第三個的寬高是指定每个動畫幀的宽度和高度。
            this.load.spritesheet('dude', 'assets/dude.png',{ frameWidth: 32, frameHeight: 48 });
        }

        function create (){
            platforms = this.physics.add.staticGroup();             //創建一個物理的靜態組件
            cursors = this.input.keyboard.createCursorKeys();       //監聽按鍵
            player = this.physics.add.sprite(100, 450, 'dude');     //創建一個物理的動態(預設)物件

            player.setBounce(0.2);                          //角色的物理反彈值
            player.setCollideWorldBounds(true);             //角色是否與邊界碰撞
            player.body.setGravityY(300)                    //給予角色重力

            scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });  //放置文字

            //增加一個圖片放在0,0位置，定位點原本預設在圖片中心，但利用setOrigin後，我把繪製定位點設定到左上角。
            this.add.image(0, 0, 'sky').setOrigin(0, 0);

            //利用靜態組件創造一個實體，可利用setScale來調整大小倍率，縮放靜態物體時，要用refreshBody(雖然用不用好像都有效)。
            platforms.create(400, 568, 'ground').setScale(2).refreshBody();
            platforms.create(600, 400, 'ground');
            platforms.create(50, 250, 'ground');
            platforms.create(750, 220, 'ground');


            this.anims.create({     //創建動畫
                key: 'left',        //名稱為left
                frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),  //展示圖片0~3幀
                frameRate: 10,      //每秒10幀
                repeat: -1          //循環播放
            });

            this.anims.create({
                key: 'turn',
                frames: [ { key: 'dude', frame: 4 } ],
                frameRate: 20
            });

            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });

            stars = this.physics.add.group({                    //給星星一個團體
                key: 'star',                                    //名稱為star
                repeat: 11,                                     //重複1+11次
                setXY: { x: 12, y: 0, stepX: 70 }               //初始x:12，每次x+70
            });

            stars.children.iterate(function (child) {
                child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));   //設置隨機0.4~0.8的Y方向反彈值
            });

            this.physics.add.collider(player, platforms);               //讓2個物件(組)可以碰撞
            this.physics.add.collider(stars, platforms);

            this.physics.add.overlap(player, stars, collectStar, null, this);   //當2物體重疊時，執行函式collectStar。
        }

        function update (){
            if (cursors.left.isDown){
                player.setVelocityX(-160);
                player.anims.play('left', true);
            }
            else if (cursors.right.isDown){
                player.setVelocityX(160);
                player.anims.play('right', true);
            }
            else{
                player.setVelocityX(0);
                player.anims.play('turn');
            }

            if (cursors.up.isDown && player.body.touching.down){    //如果按下up，並且物件底部有碰觸，則可以跳起。
                player.setVelocityY(-330);
            }
        }
        function collectStar (player, star){
            star.disableBody(true, true);   //移除物件

            score += 10;
            scoreText.setText('Score: ' + score);

            /*if (stars.countActive(true) === 0){
                //  A new batch of stars to collect
                stars.children.iterate(function (child) {

                    child.enableBody(true, child.x, 0, true, true);

                });

                //
                var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

                var bomb = bombs.create(x, 16, 'bomb');
                bomb.setBounce(1);
                bomb.setCollideWorldBounds(true);
                bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                bomb.allowGravity = false;

            }*/
        }
    </script>
</body>
</html>
